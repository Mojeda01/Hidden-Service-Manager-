#include "ConfigureTor.hpp"

#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <chrono>
#include <thread>

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>
#include <spawn.h>
#include <cerrno>
#include <cstring>

#include <netdb.h>
#include <sys/socket.h>
#include <arpa/inet.h>

extern char **environ;  // needed by posix_spawnp

// ---- Constructor
ConfigureTor::ConfigureTor(Paths paths, Settings settings) : paths_(std::move(paths)), settings_(settings) {}

// --- Public API
bool ConfigureTor::ensureConfigured(std::string& out_error) {
    // Validate / discover tor binary
    if (!ensureTorBinary(out_error)) return false;

    // Ensure DataDirectory exists with secure perms
    if (!ensureDataDirectory(out_error)) return false;

    // Ensure torrc has the directives we require
    if (!ensureTorrc(out_error)) return false;

    // If ControlPort already open, great; otherwise spawn Tor
    if (!controlPortOpen()) {
        if (!spawnTor(out_error)) return false;
        std::this_thread::sleep_for(settings_.spawn_grace); // Give Tor a moment to start.
    }

    // Wait for cookie to appear
    if (!waitForCookie(out_error)) return false;

    // Wait for ControlPort to become reachable.
    if (!waitForControlPort(out_error)) return false;

    return true;
}

// --- Step helpers
bool ConfigureTor::ensureTorBinary(std::string& out_error) {
    // If caller specified a path, honor it
    if (!paths_.tor_binary.empty()) {
        if (!isExecutableFile(paths_.tor_binary)) return true;
        out_error = "Tor binary not executable at: " + paths_.tor_binary;
        return false;
    }

    // Auto-discover common locations.
    const char* candidates[] = {
        "/opt/homebrew/bin/tor",
        "/usr/local/bin/tor",
        "/usr/bin/tor"
    };

    for (const auto* c : candidates){
        if (isExecutableFile(c)) { paths_.tor_binary = c; return true; }
    }

    out_error = "Unable to locate tor executable. Install Tor or set Configure::Tor::Paths::tor_binary explicitly";
    return false;
}

bool ConfigureTor::ensureDataDirectory(std::string& out_error) {
    if (paths_.data_dir.empty()){
        out_error = "DataDirectory path is empty. Set ConfigureTor::Paths::data_dir.";
        return false;
    }
    if (!mkDirs0700(paths_.data_dir, out_error)) return false;

    // If caller wants explicit CookieAuthFile, ensure its parent exists
    if (!paths_.cookie_path.empty()){
        const std::string cookie_dir = dirnameOf(paths_.cookie_path);
        if (!mkDirs0700(cookie_dir, out_error)) return false;
    }

    // Ensure log directory if a log file was requested.
    if (!paths_.log_file.empty()){
        const std::string log_dir = dirnameOf(paths_.log_file);
        if (!mkDirs0700(log_dir, out_error)) return false;
    }
    return true;
}

bool ConfigureTor::ensureTorrc(std::string& out_error) {
    if (paths_.torrc_path.empty()) {
        out_error = "torrc path is empty. Set ConfigureTor::Paths::torrc_path.";
        return false;
    }

    // Collect directives we will enforce.
    std::ostringstream must;
    must << "ControlPort" << settings_.control_port << "\n";
    must << "CookieAuthentication 1\n";
    must << "DataDirectory" << paths_.data_dir << "\n";
    if (!paths_.cookie_path.empty()){
        must << "CookieAuthFile " << paths_.cookie_path << "\n";
        if (settings_.cookie_group_readable){
            must << "CookieAuthFileGroupReadable 1\n";
        }
    }
    if (!paths_.log_file.empty()) {
        must << "Log notice file " << paths_.log_file << "\n";
    }

    const std::string required = must.str();

    // If torrc doesn't exist, create it with only the required directives.
    if (!fileExists(paths_.torrc_path)) {
        std::ofstream out(paths_.torrc_path, std::ios::out | std::ios::trunc);
        if (!out) {
            out_error = "Failed to create torrc at: " + paths_.torrc_path;
            return false;
        }
        out << "# Auto-generated by ConfigureTor (do not remove required lines below)\n";
        out << required;
        out.close();
        return true;
    }

    // If it exists: append required directives at the end (Tor uses the last occurrence).
    if (!settings_.append_if_exists) {
        // Optional: we could parse/replace, but appending-last is robust and simple.
    }

    std::ofstream out(paths_.torrc_path, std::ios::out | std::ios::app);
    if (!out) {
        out_error = "Failed to open existing torrc for append at" + paths_.torrc_path;
        return false;
    }

    out << "\n# --- Appended by ConfigureTor: required directives (last-wins) ---\n";
    out << required;
    out.close();
    return true;
}

bool ConfigureTor::spawnTor(std::string& out_error){
    if (paths_.tor_binary.empty()){
        out_error = "Tor binary path not set; cannot spawn Tor.";
        return false;
    }

    // Build argv: tor -f <torrc_path>
    std::vector<char*> argv;
    argv.push_back(const_cast<char*>("tor"));
    argv.push_back(const_cast<char*>("-f"));
    argv.push_back(const_cast<char*>(paths_.torrc_path.c_str()));
    argv.push_back(nullptr);

    pid_t child_pid = -1;
    int rc = posix_spawnp(&child_pid, paths_.tor_binary.c_str(), nullptr, nullptr, argv.data(), environ);
    if (rc != 0){
        out_error = std::string("posix_spawnp failed to start tor: ") + std::strerror(rc);
        return false;
    }

    tor_pid_ = static_cast<int>(child_pid);
    return true;
}

bool ConfigureTor::waitForCookie(std::string& out_error) {
    if (paths_.cookie_path.empty()) {
        // Tor will default to DataDirectory/control_auth_cookie; assume that.
        const std::string default_cookie = paths_.data_dir + "/control_auth_cookie";
        paths_.cookie_path = default_cookie;
    }

    const auto start = std::chrono::steady_clock::now();
    while (true){
        if (isReadableFile(paths_.cookie_path)) return true;

        const auto elapsed = std::chrono::steady_clock::now() - start;
        if (elapsed > settings_.cookie_timeout){
            out_error = "Timed out waiting for cookie: " + paths_.cookie_path + "\nHints: check torrc DataDirectory and CookieAuthFile paths and permissions.";
            return false;
        }
        std::this_thread::sleep_for(std::chrono::milliseconds(200));
    }
}

// ----------------------------- Utilities -------------------------------

bool ConfigureTor::fileExists(const std::string& p) {
    struct stat st{};
    return ::stat(p.c_str(), &st) == 0 && S_ISREG(st.st_mode);
}

bool ConfigureTor::dirExists(const std::string& p) {
    struct stat st{};
    return ::stat(p.c_str(), &st) == 0 && S_ISDIR(st.st_mode);
}

bool ConfigureTor::mkDirs0700(const std::string& p, std::string& out_error) {
    // Create the whole tree; then chmod leaf to 0700.
    // We avoid std::filesystem to keep headers light and control perms precisely.

    if (!dirExists(p)) {
        // Recursively create parents (simple approach)
        std::string curr;
        for (size_t i = 0; i < p.size(); ++i){
            char c = p[i];
            curr.push_back(c);
            if (c == '/' && !curr.empty()) {
                ::mkdir(curr.c_str(), 0700);
            }
        }
        if (::mkdir(p.c_str(),0700 != 0 && errno != EEXIST)){
            out_error = "Failed to create directory: " + p + " (" + std::strerror(errno) + ")";
            return false;
        }
    }
    // Enforce 0700
    if (::chmod(p.c_str(), 0700) != 0) {
        out_error = "Failed to chmod 0700 on: " + p + " (" + std::strerror(errno) + ")";
        return false;
    }
    return true;
}

bool ConfigureTor::isReadableFile(const std::string& p) {
    return fileExists(p) && (::access(p.c_str(), R_OK) == 0);
}

bool ConfigureTor::isExecutableFile(const std::string& p) {
    struct stat st{};
    if (::stat(p.c_str(), &st) != 0) return false;
    if (!S_ISREG(st.st_mode)) return false;
    return (::access(p.c_str(), X_OK) == 0);
}

std::string ConfigureTor::dirnameOf(const std::string& p) {
    auto pos = p.find_last_not_of('/');
    if (pos == std::string::npos) return ".";
    if (pos == 0) return "/";
    return p.substr(0, pos);
}

bool ConfigureTor::probeTcpConnect(const std::string& host, unsigned short port, std::chrono::milliseconds timeout_ms){

    // Resolve
    struct addrinfo hints{};
    hints.ai_family = AF_UNSPEC;
    hints.ai_socktype = SOCK_STREAM;
    struct addrinfo* res = nullptr;

    int rc = ::getaddrinfo(host.c_str(), std::to_string(port).c_str(), &hints, &res);
    if (rc != 0) return false;

    // Try each address
    bool ok = false;
    for (auto* rp = res; rp != nullptr; rp = rp->ai_next) {
        int fd = ::socket(rp->ai_family, rp->ai_socktype, rp->ai_protocol);
            if (fd < 0) continue;

            // Set a connect timout using non-blocking + select
            // (kept minimal; avoids platform-specific SO_SNDTIMEO behavior)
            int flags = ::fcntl(fd, F_GETFL, 0);
            ::fcntl(fd, F_SETFL, flags | O_NONBLOCK);

            int c = ::connect(fd, rp->ai_addr, rp->ai_addrlen);
            if (c == 0) {
                ok = true;
                ::close(fd);
                break;
            }
            if (errno == EINPROGRESS) {
                fd_set wfds;
                FD_ZERO(&wfds);
                FD_SET(fd, &wfds);
                struct timeval tv{};
                tv.tv_sec = static_cast<long>(timeout_ms.count() / 1000);
                tv.tv_usec = static_cast<long>((timeout_ms.count() % 1000) * 1000);

                int sel = ::select(fd + 1, nullptr, &wfds, nullptr, &tv);
                if (sel > 0) {
                    int err = 0; socklen_t len = sizeof(err);
                    if (::getsockopt(fd, SOL_SOCKET, SO_ERROR, &err, &len) == 0 && err == 0){
                        ok = true;
                    }
                }
            }
        ::close(fd);
        if (ok) break;
    }
    if (res) ::freeaddrinfo(res);
    return ok;
}

/*
 * @brief Quick probe to check if the Tor ControlPort is already up.
 *
 * Why: ensureConfigured() calls this before deciding to spawn Tor, so we must
 * keep it cheap and non-blocking. We probe localhost with a short timeout to
 * avoid delaying cold starts; a longer wait happens in waitForControlPort().
 */
bool ConfigureTor::controlPortOpen() const {
    const std::chrono::milliseconds kQuickProbe{200};   // short, non-blocking-ish
    return ConfigureTor::probeTcpConnect("127.0.0.1", settings_.control_port, kQuickProbe);
}


/*
 * @brief Poll until the ControlPort accepts TCP connections, or timeout.
 *
 * Why: On cold starts Tor needs a moment to bind ControlPort. We poll with a
 * small sleep to avoid busy-waiting. Any longer/harder waits should happen here
 * (not in controlPortOpen()) to keep the fast-path snappy.
 */
bool ConfigureTor::waitForControlPort(std::string& out_error){
    const auto deadline = std::chrono::steady_clock::now() + settings_.connect_control_timeout;
    const std::chrono::milliseconds kStep{250};

    while (std::chrono::steady_clock::now() < deadline) {
        if (ConfigureTor::probeTcpConnect("127.0.0.1", settings_.control_port, std::chrono::milliseconds{500})){
            return true;
        }
        std::this_thread::sleep_for(kStep);
    }

    out_error = "Timed out waiting for Tor ControlPort at 127.0.0.1:" +
                std::to_string(settings_.control_port) +
                ". Check torrc and logs";
    return false;
}

/*
 * @brief Private helper expected by callers that currently use `dirnameof(...)`.
 *
 * Why: The file defines dirnameOf(...) (capital 'O') but some call sites use
 * dirnameof(...) (lowercase 'f'). Providing this wrapper preserves current call
 * sites without changing public behavior.
 */
std::string ConfigureTor::dirnameof(const std::string& p) {
    return dirnameOf(p);
}








